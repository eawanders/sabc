name: Update Outing Status

on:
  schedule:
    - cron: "*/10 * * * *" # every 10 minutes
  # Allow manual runs from the Actions UI for testing
  workflow_dispatch: {}

# Set default permissions to minimum (read-only)
permissions:
  contents: read

jobs:
  update-status:
    # Prevent overlapping runs and limit concurrency
    concurrency:
      group: update-outing-status
      cancel-in-progress: true
    runs-on: ubuntu-latest

    # No additional permissions needed for this job
    permissions:
      contents: read

    # Use a protected GitHub Environment to host secrets and apply deployment protections
    # The CRON_HMAC_KEY secret should be set in the environment (not repository secrets)
    environment:
      name: outing-update

    steps:
      - name: Generate HMAC signature
        id: sign
        env:
          CRON_HMAC_KEY: ${{ secrets.CRON_HMAC_KEY }}
        run: |
          set -euo pipefail

          # Generate timestamp (milliseconds since epoch)
          TIMESTAMP=$(date +%s%3N)

          # Create payload with nonce from GitHub run ID
          PAYLOAD="{\"nonce\":\"${{ github.run_id }}\",\"workflow\":\"${{ github.workflow }}\"}"

          # Compute HMAC signature
          MESSAGE="${TIMESTAMP}.${PAYLOAD}"
          SIGNATURE=$(echo -n "$MESSAGE" | openssl dgst -sha256 -hmac "$CRON_HMAC_KEY" | cut -d' ' -f2)

          # Output for next step (masked from logs)
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "payload=$PAYLOAD" >> $GITHUB_OUTPUT
          echo "::add-mask::$SIGNATURE"
          echo "signature=$SIGNATURE" >> $GITHUB_OUTPUT

      - name: Trigger Outing Status Update
        env:
          TIMESTAMP: ${{ steps.sign.outputs.timestamp }}
          SIGNATURE: ${{ steps.sign.outputs.signature }}
          PAYLOAD: ${{ steps.sign.outputs.payload }}
        run: |
          set -euo pipefail
          URL="https://sabc-woad.vercel.app/api/update-outing-status"

          # Send HMAC-signed request
          RESPONSE_FILE=$(mktemp)
          HTTP_STATUS=$(curl -sS -w "%{http_code}" -o "$RESPONSE_FILE" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "x-cron-timestamp: $TIMESTAMP" \
            -H "x-cron-signature: $SIGNATURE" \
            -L --location-trusted \
            --connect-timeout 10 \
            --max-time 30 \
            --retry 3 --retry-delay 5 \
            --data "$PAYLOAD" \
            "$URL") || true

          # Read response snippet (truncated for security)
          RESPONSE_SNIPPET=$(head -c 1024 "$RESPONSE_FILE" | tr -d '\r' || true)
          rm -f "$RESPONSE_FILE"

          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
            echo "[outing-status-cron] Success: HTTP $HTTP_STATUS"
            if [ -n "$RESPONSE_SNIPPET" ]; then
              echo "[outing-status-cron] Response: ${RESPONSE_SNIPPET}"
            fi
          else
            echo "[outing-status-cron] Failure: HTTP $HTTP_STATUS"
            if [ -n "$RESPONSE_SNIPPET" ]; then
              echo "[outing-status-cron] Response (truncated): ${RESPONSE_SNIPPET}"
            fi
            exit 1
          fi
