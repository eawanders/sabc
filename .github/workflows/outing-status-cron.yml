name: Update Outing Status

on:
  schedule:
    - cron: "*/10 * * * *" # every 10 minutes
  # Allow manual runs from the Actions UI for testing
  workflow_dispatch: {}

jobs:
  update-status:
    # Prevent overlapping runs and limit concurrency
    concurrency:
      group: update-outing-status
      cancel-in-progress: true
    runs-on: ubuntu-latest
    # Grant the workflow the least privilege: it doesn't need to read repository contents
    permissions: {}
    # Use a protected GitHub Environment to host the secret and apply deployment protections.
    # Create an environment named `outing-update` in the repository settings and add
    # the secret `UPDATE_OUTING_STATUS_SECRET` there. The job will require environment
    # approval/policies if configured.
    environment:
      name: outing-update
    env:
      TOKEN: ${{ secrets.UPDATE_OUTING_STATUS_SECRET }}
    steps:
      - name: Trigger Outing Status Update
        run: |
          set -euo pipefail
          URL="https://sabc-woad.vercel.app/api/update-outing-status"

          # Send request and capture status and a short response body (first 8KB)
          RESPONSE_FILE=$(mktemp)
          # Follow redirects (-L) and allow sending the same Authorization header
          # on redirects (--location-trusted). Add a connect timeout and retries
          # to be more resilient to transient network errors.
          HTTP_STATUS=$(curl -sS -w "%{http_code}" -o "$RESPONSE_FILE" \
            -X POST \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -L --location-trusted \
            --connect-timeout 10 \
            --max-time 30 \
            --retry 3 --retry-delay 5 \
            "$URL") || true

          # Read a short snippet of the response for logs (avoid huge bodies)
          RESPONSE_SNIPPET=$(head -c 8192 "$RESPONSE_FILE" | tr -d '\r' || true)
          rm -f "$RESPONSE_FILE"

          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
            echo "[outing-status-cron] Success: HTTP $HTTP_STATUS"
            if [ -n "$RESPONSE_SNIPPET" ]; then
              echo "[outing-status-cron] Response: ${RESPONSE_SNIPPET}"
            fi
          else
            echo "[outing-status-cron] Failure: HTTP $HTTP_STATUS"
            if [ -n "$RESPONSE_SNIPPET" ]; then
              echo "[outing-status-cron] Response (truncated): ${RESPONSE_SNIPPET}"
            fi
            exit 1
          fi
